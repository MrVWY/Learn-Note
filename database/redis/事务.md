## 事务
Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：

1. 批量操作在发送 EXEC 命令前被放入队列缓存。 
2. 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。 
3. 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。
  
一个事务从开始到执行会经历以下三个阶段：
  
1. 开始事务 
2. 命令入队 
3. 执行事务

使用 MULTI 命令 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令

### Redis 事务保证原子性吗，支持回滚吗
不保证，不支持
单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。

事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，`中间某条指令的失败不会导致前面已做指令的回滚`，也不会造成后续的指令不执行

### Redis 事务支持隔离性吗
Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的

### WATCH 命令
WATCH命令可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行（类似于乐观锁）。执行EXEC命令之后，就会自动取消监控。  
```
127.0.0.1:6379> watch name
OK
127.0.0.1:6379> set name 1
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set name 2
QUEUED
127.0.0.1:6379> set gender 1
QUEUED
127.0.0.1:6379> exec
(nil)
127.0.0.1:6379> get gender
(nil)

```
1. watch name开启了对name这个key的监控 
2. 修改name的值 
3. 开启事务 a 
4. 在事务 a 中设置了name和gender的值 
5. 使用EXEC命令进提交事务 
6. 使用命令get gender发现不存在，即事务 a 没有执行

