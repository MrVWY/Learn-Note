1. MySQL 表t1 使用InnoDB 引擎，以下哪个场景会导致语句 Q1:select * from t1 limit 1 被堵住?(多选)ABC
A:另一个线程在 Q1 执行之前，执行了 alter table tl add index(fl)，当前处于"拷贝数据到临时表”阶段
B:另一个线程在 Q1 执行之前，执行了 truncate table tl，当前处于 waiting for metadata lock 阶段
C:另一个线程在 Q1 执行之前，执行了 delete form tl，且未执行完成
D:另一个线程在 Q1 执行之前，执行了 1ock table tl write，并执行完成
```
正确答案：
A: 另一个线程在 Q1 执行之前，执行了 alter table tl add index(fl)，当前处于"拷贝数据到临时表”阶段。
在执行 ALTER TABLE 时，InnoDB 会对表加锁，因此会阻塞查询。

B: 另一个线程在 Q1 执行之前，执行了 truncate table tl，当前处于 waiting for metadata lock 阶段。
TRUNCATE 会获得元数据锁，阻塞其他操作。

C: 另一个线程在 Q1 执行之前，执行了 delete from tl，且未执行完成。
如果 DELETE 操作还在进行中，可能会持有行级锁，从而阻塞读取。

错误答案：
D: 另一个线程在 Q1 执行之前，执行了 lock table tl write，并执行完成。
如果 LOCK TABLES 已经执行并完成，锁定操作已释放，不会影响后续的查询。

因此，选项 A, B, C 会导致 Q1 被堵住。
```

2.关于 MySQL 自增主键，以下说法错误的是?(多选)AC
A:自增主键字段在达到定义类型上限后，再插入一行记录，则会报“主键冲突”错误
B:一个只有insert场景，且所有insert 语句都不指定自增主键值的表，自增主键列的值一定是连续且递增的
C:将自增主键定义从int 修改成 bigint 的时候，会导致全表重做
D:在一个空表里，先指定自增主键值是10，插入一行记录;然后，以不指定自增值的方式插入10行数据，会报“主键冲突”错误

```
错误选项：
B: 一个只有 insert 场景，且所有 insert 语句都不指定自增主键值的表，自增主键列的值一定是连续且递增的。
自增主键的值可能由于删除记录或回滚事务而不连续，因此不一定是连续的。

D: 在一个空表里，先指定自增主键值是10，插入一行记录; 然后，以不指定自增值的方式插入10行数据，会报“主键冲突”错误。
在这种情况下，自增主键会从 11 开始插入，所以下一行的自增值将是 11，不会发生冲突。

正确选项：
A: 自增主键字段在达到定义类型上限后，再插入一行记录，则会报“主键冲突”错误。
这是正确的描述。

C: 将自增主键定义从 int 修改成 bigint 的时候，会导致全表重做。
这个说法是正确的，因为修改列的类型会导致重建表。

MySQL 的自增主键（AUTO_INCREMENT）是一种非常常见的用法，用于为表中的每一行自动生成唯一的标识符。以下是关于 MySQL 自增主键的一些重要信息和用法：

1. 自增主键的定义
自增主键是一个整型字段，在插入新记录时，MySQL 会自动为该字段生成一个唯一的值。一般情况下，这个值是从 1 开始的，每次插入新的行时自动递增。

2. 注意事项
数据类型：通常自增主键使用 INT 或 BIGINT 数据类型，但也可以使用其他整型类型。
并发插入：在高并发插入的情况下，自增值生成可能会出现性能瓶颈，需注意优化数据库配置。
删除记录：删除记录后，自增值不会回收，新的插入仍会继续从当前最大值递增。

3. 自增主键的替代方案
虽然自增主键是常用的方法，但在某些情况下（如分布式系统），可能需要使用 UUID 或其他生成策略来确保唯一性和分布性。
```

3.MySQL RR 隔离级别下，表t的建表结构和初始化数据如下:(单选)
```
create table t(id int primary key,c int) engine=innodb;
insert intotvalues(l,1),(11,11),(2l,21);
```
在会话1执行如下语句:
```
begin;
select *from t lock in share mode;
```
那么，会话2的以下哪些语句会被进入“等待行锁”的状态?BC
A:insert into t values(15,15);
B:update t set c=c+l where id=l5;
C:delete from t where id=l5;
D:alter table t add d int;

```
在 MySQL 的可重复读（RR）隔离级别下，会话1执行 SELECT ... LOCK IN SHARE MODE 会对读取的行加上共享锁。共享锁允许其他事务读取，但不允许修改。

在这种情况下，以下选项将会进入“等待行锁”的状态：

A: insert into t values(15,15); - 不会等待，因为插入新行不会影响现有行的锁定。
B: update t set c=c+1 where id=15; - 会等待，因为这是对已经锁定的行进行更新。
C: delete from t where id=15; - 会等待，因为这是对已经锁定的行进行删除。
D: alter table t add d int; - 不会等待，DDL 操作会获得表级锁，不受行锁影响。
因此，B 和 C 会进入“等待行锁”的状态
```

4.以下关于使用 MySQL 索引，说法正确的是?(多选)BCD
A:查询条件是 wherek=N，并且 N 和 k 的数据类型不一致时，一定无法使用索引
B:查询条件是 where k+l=N 时，一定无法使用索引
C:当能够使用索引时，extra 字段会显示 using index
D:语句指定force index使用一个索引的时候，优化器就不会去判断其他索小的执行代价了
```
关于使用 MySQL 索引的说法，正确的是：

A: 错误。虽然数据类型不一致可能影响索引的使用，但并不一定无法使用索引。MySQL 会尝试进行类型转换。

B: 正确。当查询条件是 WHERE k + l = N 时，无法直接使用索引，因为索引不能优化此类计算。

C: 正确。当能使用索引时，EXTRA 字段会显示 Using index，这表示查询是通过索引来满足的。

D: 正确。当使用 FORCE INDEX 指定一个索引时，优化器将强制使用该索引，可能忽略其他索引的执行代价判断。

因此，正确的选项是 B, C, D。
```
