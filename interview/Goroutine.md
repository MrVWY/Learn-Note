### goroutine 为什么那么“快”

#### 进程、线程、协程
- 进程：进程是系统进行资源分配的基本单位，有独立的内存空间。
- 线程：线程是 CPU 调度和分派的基本单位，线程依附于进程存在，每个线程会共享父进程的资源。
- 协程：协程是一种用户态的轻量级线程，协程的调度完全由用户控制，协程间切换只需要保存任务的上下文，没有内核的开销。

#### Goroutine 非常轻量，主要体现在以下两个方面：
- 上下文切换代价小： Goroutine 上下文切换只涉及到少量的寄存器修改。而对比线程的上下文切换则需要涉及模式切换（从用户态切换到内核态）、以及寄存器的刷新。
- 内存占用少：线程栈空间通常是 2M，Goroutine 栈空间最小 2K。Golang 程序中可以轻松支持 10W 级别的 Goroutine 运行，而线程数量达到 1K 时，内存占用就已经达到 2G。

#### 调度机制GPM
自行看资料
- G（Goroutine）
- P（Processor）
- M（Machine）
- Go 调度器 Sched

&ensp;&ensp;Go 程序可以利用少量的内核级线程来支撑大量 Goroutine 的并发。多个 Goroutine 通过用户级别的上下文切换来共享内核线程 M 的计算资源，
但对于操作系统来说并没有线程上下文切换产生的性能损耗。

&ensp;&ensp;为了更加充分地利用线程的计算资源，Go 调度器采取了以下几种调度策略：
- 任务窃取（work-stealing） ：有的 Goroutine 运行快，有 Goroutine 运行慢。当每个 P 之间的 G 任务不均衡时，调度器允许从 GRQ，或者其他 P 的 LRQ 中获取 G 执行。
- 减少阻塞 ：如果正在执行的 Goroutine 阻塞了线程 M, 有一下几种场景
  + 由于原子、互斥量或通道操作调用导致 Goroutine 阻塞。调度器将把当前阻塞的 Goroutine 切换出去，重新调度 LRQ 上的其他 Goroutine
  + 在调用一些系统方法的过程中发生阻塞。这种情况下，网络轮询器无法使用，而进行系统调用的 Goroutine 将阻塞当前 M。此时，调度器将阻塞的 M 与 P 分离，
    同时创建新 M 来服务 P
  + 如果在 Goroutine 中执行一个 sleep 操作，导致 M 被阻塞了。 Go 程序后台有一个监控线程 sysmon，它监控那些长时间运行的 G 任务然后设置可以抢占
    的标识符，别的 Goroutine 就可以抢先进来执行
  + 由于网络请求和 IO 操作导致 Goroutine 阻塞。此时，Go 程序会提供网络轮询器（NetPoller）来处理网络请求和 IO 操作的问题，其
    后台通过 kqueue（MacOS），epoll（Linux）或 iocp（Windows）来实现 IO 多路复用。通过使用网络轮询器进行网络系统调用，
    调度器可以防止 Goroutine 在进行这些系统调用时阻塞 M。这可以让 M 执行 P 的 LRQ 中其他的 Goroutines，而不需要创建新的 M。
    有助于减少操作系统上的调度负载