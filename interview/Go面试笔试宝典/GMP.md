## CPU物理数，核心数，线程数

### CPU物理数

即电脑拥有的物理CPU数量，普通电脑一般只有一个CPU插槽，也就是只有一个物理CPU。我们日常说的CPU，就是指封装好的一个物理CPU，作为商品进行售卖。但在编程讨论时，某些情况下，我们说的CPU含义又是指其中一个运算单元，即下面的说的【CORE核心】。



### CORE核心数(物理核心数)

核心数为一个物理CPU拥有的运算单元数量，例如8核，即一个CPU有8个核心，拥有8个独立的运算单元。一个运算单元有一套寄存器，一般还有L1，L2的私有缓存，可以独立执行一个任务(一般是线程)，所以一个核心同一时刻只能运行一个线程，不论这个线程是哪个进程的。
每隔一定时间，大概几十毫秒，就会切换线程，即切换任务（可能是同一个进程的线程，也可能是另外一个进程的线程，如果是其它进程的线程，会切换CR3）。

### THREAD线程数(逻辑核心数)

一般来说，一个物理核心就是一个独立的运算单元，一个物理核心(运算单元)同时最多运行一个线程，也就是一个线程数。但是英特尔的超线程技术，可以实现一个核心同时执行多个线程，则产生了逻辑核心数的说法：就是我们说的8核16线程，一个核心能跑二个线程，核心数是8，线程数就是16。

### 线程是CPU调度和分配的基本单位 的理解

有句话说CPU核心只能看到线程，可以这么理解：假设我是CORE核心，我闭着眼(等待进程调度)，操作系统调度器将一个进程分配给我之后，我拿到进程睁开眼(分配到一个进程)，开始工作时我看到的是什么？
我看到的是进程中的很多线程和分配给我的资源，那么我现在能执行的是什么？进程？不行，因为我看不到其他进程(进程都是独立和隔离的)，何来调度分配？

线程才是真正执行的单位，而执行任务的是CORE核心。于是有【线程是CPU调度和分配的基本单位】。也解释了【不论这个线程是哪个进程的，CPU眼里没有进程的概念这个说法】


### 进程是操作系统进行资源分配的最小单位 的理解

线程和进程的关系是密切的，前面所说[线程是CPU调度和分配的基本单位]，但是计算机资源是多种多样的（包括CPU『这里的CPU指CORE核心』、内存、磁盘IO等），
因此操作系统在分配这些资源的时候，是以进程为单位进行分配。操作系统调度的也是进程。

【线程是CPU调度和分配的基本单位】一定要和【进程是操作系统进行资源分配的最小单位】区别清楚和理解

### 属于同个进程下的多个线程，是跑在不同的核上还是只能跑在同个核上？

在大多数支持多核的操作系统上，都能实现把一个进程的多个线程放不同的核心上跑。一个进程可能由多个线程组成，而线程的实现有两种方式，一种是内核调度的线程，可以运行在多个核上，
还有一种是用户级线程，这个就没办法跑到多个核上了

### 线程

#### 用户级线程

用户级线程是指不需要内核支持而在用户程序中实现的线程，它的内核的切换是由用户态程序自己控制内核的切换，不需要内核的干涉。但是它不能像内核级线程一样更好的运用多核CPU。

#### 内核级线程

内核级线程是指切换由内核控制的线程，当线程进行切换的时候，由用户态转化为内核，切换完毕要从内核态返回用户态。

## 传统并发
传统并发的方式，其实是多线程。但是多线程除了每个线程的占用较大栈空间外(至少 2M)，最大的问题就是线程的调度是由内核控制。

即线程上下文切换(同一个进程中)会从 用户态 -> 内核态 -> 用户态，很多上线文信息都是保存在内存中的，一次切换就是一次 I/O (内存的读写)，这明显这是一个耗性能杀手的操作。

Golang 中有一个协程的概念，其实简单理解就是更轻量级的调度单元。它有两个最大的特点:占用栈空间小(2KB ～ 2GB)上下文都在用户态切换，不会涉及到内核态

## GMP

### G
可以理解为用户级线程

### M
Go 对操作系统线程（OS thread）的封装，可以看作操作系统内核线程

m 只关心 curg 和 g0 两个 Goroutine。

curg 是在当前线程上运行的用户 Goroutine

### P
逻辑处理器，是 cpu核 的抽象，可以简单理解为一个 p 就是 cpu 一核。可以通过设置 GOMAXPROCS 来设置 P 的数量。其实 P 的数量，代表了并行的能力，一个 M(线程) 对应 一个 P， 如果 M 数量大于 P，多出来的 M 就只有阻塞排队。所以最好就是有几核就设置几个 P，几个 M。
