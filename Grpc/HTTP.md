影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。

### HTTP/1.0

&ensp;&ensp;每进行一次HTTP通信，都需要经历建立TCP连接、传输HTTP数据和断开TCP连接三个阶段,这样就会引发一个问题：当
单个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，如果在下载每个文件的时候，
都需要经历建立TCP连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。

### HTTP/1.1

&ensp;&ensp;为了解决这个HTTP/1.0的这个问题，
HTTP/1.1中增加了持久连接的方法，它的特点是在一个TCP连接上可以传输多个HTTP 请求，
只要浏览器或者服务器没有明确断开连接，那么该TCP连接会一直保持。  

&ensp;&ensp;HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。

#### 队头阻塞(head-of-line blocking)的问题
&ensp;&ensp;持久连接虽然能减少TCP的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。
如果TCP通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求。  
&ensp;&ensp;解决方案
- 并发连接
- 域名分片

### HTTP/2

#### 头部压缩
  + 在 HTTP/1.1 及之前的时代，请求体一般会有响应的压缩编码过程，通过 Content-Encoding 头部字段来指定。
  HTTP1.x 的 header 带有大量信息，而且每次都要重复发送（当请求字段非常复杂的时候，尤其对于 GET 请求，请求报文几乎全是请求头），
  HTTP/2 针对头部字段，也采用了对应的压缩算法—— HPACK，对请求头进行压缩。
#### 多路复用（新增一个概念---`新的二进制格式（Binary Format）二进制分帧` ）
  + HTTP1.x 协议里的报文（主要指的是头部）不使用二进制数据，而是文本形式。（文本的表现形式有多样性，文本、图片、视频等任意数据）
  + 原来的 Headers + Body 的报文格式如今被拆分成了一个个二进制的帧，用 Headers 帧存放头部字段，Data 帧存放请求体数据。分帧之后，
  服务器看到的不再是一个个完整的 HTTP 请求报文，而是`一堆乱序的二进制帧`。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。

&ensp;&ensp;通信双方都可以给对方发送二进制帧，这种 二进制帧的双向传输的序列，也叫做 流 (Stream) 。HTTP/2 用流来在一个 TCP 连接上来进行多个
数据帧的通信，这就是【多路复用】的概念。  
##### 如何来处理这些乱序的数据帧
&ensp;&ensp;所谓的乱序，指的是不同 ID 的 Stream 是乱序的。不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。
二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的请求报文和响应报文。

#### 服务器推送（Server Push）
&ensp;&ensp;在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，
当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。

#### 设置请求优先级
&ensp;&ensp;设置数据帧的优先级，让服务端先处理重要资源

### HTTPS
&ensp;&ensp; HTTPS = HTTP + TLS/SSL
&ensp;&ensp; 看图->httpsflow.png、certificateauthority.png