

### 数据类型

#### String（字符串）

​	string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。

​	string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。

​	string 类型是 Redis 最基本的数据类型，string 类型的值（一个键）最大能存储 512MB。

```
redis 127.0.0.1:6379> SET r "1"
OK
redis 127.0.0.1:6379> GET r
1
```

#### Hash(哈希)

Redis hash 是一个键值(key=>value)对集合。

Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。

```
redis 127.0.0.1:6379> HMSET runoob field1 "Hello" field2 "World"
"OK"
redis 127.0.0.1:6379> HGET runoob field1
"Hello"
redis 127.0.0.1:6379> HGET runoob field2
"World"
```

每个 hash 可以存储 2^32 -1 键值对（40多亿）

#### List（列表）

Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）

```
redis 127.0.0.1:6379> lpush runoob redis
(integer) 1
redis 127.0.0.1:6379> lpush runoob mongodb
(integer) 2
redis 127.0.0.1:6379> lpush runoob rabbitmq
(integer) 3
redis 127.0.0.1:6379> lrange runoob 0 10
1) "rabbitmq"
2) "mongodb"
3) "redis"
redis 127.0.0.1:6379>
```

列表最多可存储 2^32 - 1 元素 (4294967295, 每个列表可存储40多亿)

#### Set（集合）

Redis 的 Set 是 string 类型的无序集合。

集合set是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。

##### sadd 命令

添加一个 string 元素到 key 对应的 set 集合中，成功返回 1，如果元素已经在集合中返回 0。

```
sadd key member
```

```
redis 127.0.0.1:6379> sadd runoob redis
(integer) 1
redis 127.0.0.1:6379> sadd runoob mongodb
(integer) 1
redis 127.0.0.1:6379> sadd runoob rabbitmq
(integer) 1
redis 127.0.0.1:6379> sadd runoob rabbitmq
(integer) 0
redis 127.0.0.1:6379> smembers runoob

1) "redis"
2) "rabbitmq"
3) "mongodb"
```

**注意：**以上实例中 rabbitmq 添加了两次，但根据**集合内元素的唯一性**，第二次插入的元素将被忽略。

集合中最大的成员数为 2^32 - 1(4294967295, 每个集合可存储40多亿个成员)。

#### zset(sorted set：有序集合)

Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。

不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

zset的成员是唯一的,但分数(score)却可以重复

##### zadd 命令

添加元素到集合，元素在集合中存在则更新对应score

```
zadd key score member 
```

```
redis 127.0.0.1:6379> zadd runoob 0 redis
(integer) 1
redis 127.0.0.1:6379> zadd runoob 0 mongodb
(integer) 1
redis 127.0.0.1:6379> zadd runoob 0 rabbitmq
(integer) 1
redis 127.0.0.1:6379> zadd runoob 0 rabbitmq
(integer) 0
redis 127.0.0.1:6379> ZRANGEBYSCORE runoob 0 1000
1) "mongodb"
2) "rabbitmq"
3) "redis"
```

##### 跳跃表

![](1.jpg)

跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。

###### 时间复杂度

​	如果一个链表有 n 个结点，如果每两个结点抽取出一个结点建立索引的话，那么级索引的结点数大约就是 n/2，第二级索引的结点数大约为 n/4，以此类推第 m 级索引的节点数大约为
$$
n/(2^m)
$$
​	查询跳表的时候，如果每一层都需要遍历 k 个结点，那么时间复杂度就为
$$
O(k * log(n))
$$
​	K为常数，时间复杂度就为
$$
O(log(n))
$$
​	

###### 空间复杂度

空间复杂度就是每层节点和
$$
O(n)
$$


###### 为什么选择跳跃表

1. 普通 BST 插入元素越有序效率越低，最坏情况会退化回链表
2. 平衡树的插入和删除操作可能引发子树的调整平衡过程比较复杂，实现起来麻烦（如AVL树需要LL、LR、RL、RR四种旋转操作保持平衡，红黑树则需要左旋、右旋和节点变色三种操作），而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。
3. 实现简单

###### 查找

​	假设要查找的数据为x，同时每2个节点抽出来作为索引，在第 k 级索引中，遍历到 y节点之后，发现 x 大于 y，小于后面的节点 z，所以通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个节点（包含 y 和 z），所以，在 k-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个节点。

### 命令

### 持久化

#### AOF 持久化

​	以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

​	Redis 会将命令先写入到AOF缓冲区，再写入AOF文件。

​	AOF缓冲区同步文件的三个策略。

- always 策略：命令写入AOF缓冲区以后会调用系统fsync 操作同步到AOF文件，fsync完成后线程返回。这里的fsync是针对单个文件的操作，在进行磁盘同步的时候会阻塞直到写入磁盘完成以后返回，从而保证数据持久化的完成。
- everysec 策略：命令写入AOF缓冲区以后调用write操作，write完成后线程返回。此操作会有专门线程执行每秒执行一次。这里的write操作会触发延迟写(delayed write)机制，Linux 内核提供页缓冲区来提高硬盘IO性能。也就是说write 操作写入系统缓冲区以后就返回了，同步硬盘依赖于操作系统调度机制完成。(Redis默认配置)
- no策略：此种刷新策略是根据操作系统来决定的，也就是由操作系统来决定什么时候将缓冲区的数据写入到磁盘中。由于是操作系统来决定持久化，所以这种方式是不可控的。

##### AOF 重写

AOF缓冲区会将Redis Client请求的命令源源不断地同步到AOF文件中，同时AOF文件会不断增大，这里就需要AOF重写。AOF重写就是把Redis进程内的数据转化为写命令同步到新的AOF文件的过程。其目的就是使重写后的AOF文件变得更小：

- 进程内已经超时的数据不会再写入AOF文件中。
- 旧AOF文件含有的无效命令，可以通过进程内的数据直接生成，新的AOF文件只保留最终的数据写入命令。例如就文件中存在三条命令，它们依次是“set hello A”、 “set hello B”和“set hello C”，对同一个key 进行负值只有最后一句“set hello C”是起效的，所以这三条命令会被“set hello C”一条命令替换，并且保存到新的AOF文件中。
- 另外，多条写命令可以合并成一个。例如依次存在三个命令：“lpush list A”、 “lpush list B”和“lpush list C”，这里就可以合并为一条命令“lpush list A B C”。

AOF重写不仅降低了文件的占用空间，同时更小的AOF也可以更快地被Redis加载。

#### RDB持久化

​	在指定的时间间隔内将内存中的数据集快照写入磁盘，际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储

#### 比较

1. 体积大小/恢复速度：RDB是使用二进制压缩的模式保存，因此体积会比较小，在Redis恢复的时候加载的速度也会更快。相反AOF写入的是日志的形式，因此体积会较大，恢复速度也会慢些。
2. 资源消耗：RDB显示需要消耗的资源会更大，因为每次将全量的数据保存到磁盘中。而AOF每次可以保存增量的Redis数据。
3. 数据：RDB是以快照的模式保存数据，对数据的保存不是实时性的，会有丢失数据的可能性。而在这方面AOF的日志方式数据丢失的几率会比RDB好很多

### 缓存穿透

​	当用户访问的数据，**既不在缓存中，也不在数据库中**，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。

#### 解决方案

1. 当查找一个不在数据库/redis里面的数据时，设置一个空值，后续查询直接返回空值
2. 布隆过滤器：在数据写入数据库的同时将这个 ID 同步到到布隆过滤器中，当请求的 id 不存在布隆过滤器中则说明该请求查询的数据一定没有在数据库中保存，就不要去数据库查询了。

### 缓存击穿

​	缓存中的**某个热点数据过期**了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮

#### 解决方案

1. 设置过期时间+随机时间，
2. 加锁，保证只有一个请求去读取数据并加载到redis
3. 提前把热点数据存入redis中

### 缓存雪崩

​	当**大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机**时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃

#### 解决方案

1. 过期时间添加随机值，确保不会同一时刻热点数据全部失效
2. 接口限流

